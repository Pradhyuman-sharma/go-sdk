package integrations

import (
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	"github.com/keploy/go-sdk/keploy"
	"go.uber.org/zap"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// NewMongoCollection creates and returns an instance of MongoCollection that contains actual
// pointer to mongo's collection. This is done in order to mock mongo CRUD operations. Also logger
// is initialized
//
// cl parameter is pointer to mongo's collection instance created by (*mongo.Database).Collection
// method. If it is nil then, output of mongoDB operations won't be stored in keploy's context 
func NewMongoCollection(cl *mongo.Collection) *MongoCollection {
	gob.Register(primitive.ObjectID{})
	logger, _ := zap.NewProduction()
	defer func(){
		_ = logger.Sync() // flushes buffer, if any
	}()
	return &MongoCollection{Collection: *cl, log: logger}
}

// In order to mock mongo operations, mongo collection is embedded into MongoCollection
type MongoCollection struct {
	mongo.Collection
	log *zap.Logger
}

// MongoSingleResult countains instance of mongo.SingleResult to mock its methods
type MongoSingleResult struct {
	mongo.SingleResult
	filter interface{}
	opts []options.FindOneOptions
	ctx context.Context
	log *zap.Logger
}

// Err mocks mongo's SingleResult Err() in order to :
// 1. in "capture" mode, store its encoded output(generated by SingleResult.Err()) into keploy's Context Deps array.
// 2. in "test" mode, decode its stored output which are present in the keploy's Context Deps array without calling SingleResult.Err().
// 3. in "off" mode, returns the output generated after calling Err method of SingleResult. 
//
// This method returns error occured while execution of FindOne method that created this SingleResult.
// If there is no matching document in collection then, ErrNoDocuments error is returned. 
func (msr *MongoSingleResult) Err() error {
	if keploy.GetMode() == "off" {
		err := msr.SingleResult.Err()
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(msr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
	case "capture":
		err = msr.SingleResult.Err()
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "FindOne.Err",
		"filter":	 fmt.Sprint(msr.filter),
		"FindOneOptions": fmt.Sprint(msr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(msr.ctx, msr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Decode mocks Decode method of SingleResult in order to: 
// 1. in "capture" mode, store its encoded output(after calling Decode) in the keploy's Context Deps array .
// 2. in "test" mode, decode the stored output from the keploys' Context Deps array without calling Decode.
// 3. in "off" mode, returns the output from calling actual Decode method.
//
// Actual Decode method unmarshals the document represented by this SingleResult into v. If there
// was an error from the operation that created this SingleResult, that error will be returned. 
// If the operation returned no documents, Decode will return ErrNoDocuments.
//
// If v is nil or is a typed nil, an error will be returned.
func (msr *MongoSingleResult) Decode(v interface{}) error {
	if keploy.GetMode() == "off" {
		err := msr.SingleResult.Decode(v)
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(msr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
	case "capture":
		err = msr.SingleResult.Decode(v)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "FindOne.Decode",
		"filter":	 fmt.Sprint(msr.filter),
		"FindOneOptions": fmt.Sprint(msr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(msr.ctx, msr.log, meta, v, kerr)

	if mock {
		var mockErr error
		// rv := reflect.ValueOf(v)
		// rv.Elem().Set(reflect.ValueOf(res[0]).Elem())

		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// FindOne method creates and returns pointer of MongoSingleResult which containes mocked methods
// of mongo.SingleResult. It calls mongo's FindOne operation of mongo collection only in "capture" 
// or "off" mode.
//
// The filter parameter must be a document containing query operators and can be used to select the document to be
// returned. It cannot be nil. If the filter does not match any documents, a SingleResult with an error set to
// ErrNoDocuments will be returned. If the filter matches multiple documents, one will be selected from the matched set.
//
// The opts parameter can be used to specify options for this operation (see the options.FindOneOptions documentation).
func (c *MongoCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) *MongoSingleResult {
	if keploy.GetMode() == "off" {
		sr := c.Collection.FindOne(ctx, filter, opts...)
		return &MongoSingleResult{
			SingleResult: *sr,
			filter: 	  filter,
			log:          c.log,
			ctx:          ctx,
		}
	}
	derivedOpts := []options.FindOneOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return &MongoSingleResult{
			filter: filter,
			opts: 	derivedOpts,
			log: c.log,
			ctx: ctx,
		}
	}
	mode := kctx.Mode
	var sr *mongo.SingleResult
	switch mode {
	case "test":
		return &MongoSingleResult{
			filter: filter,
			opts: 	derivedOpts,
			log: c.log,
			ctx: ctx,
		}
	case "capture":
		sr = c.Collection.FindOne(ctx, filter, opts...)
	default:
		return &MongoSingleResult{
			filter: filter,
			opts: 	derivedOpts,
			log: c.log,
			ctx: ctx,
		}
	}

	return &MongoSingleResult{
		SingleResult: *sr,
		filter: 	  filter,
		opts: 		  derivedOpts,
		log:          c.log,
		ctx:          ctx,
	}
}

// InsertOne method mocks Collection.InsertOne of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.InsertOne) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.InsertOne.
// 3. in "off" mode, returns the output from calling actual Collection.InsertOne method.
// 
// document parameter should not be nil. It is the document to be inserted into collection.
func (c *MongoCollection) InsertOne(ctx context.Context, document interface{},
	opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.InsertOne(ctx, document, opts...)
		return output, err
	}
	var output *mongo.InsertOneResult = &mongo.InsertOneResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, document)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "InsertOne", data)
	if o != nil {
		output = o.(*mongo.InsertOneResult)
	}
	err = e

	derivedOpts := []options.InsertOneOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "InsertOne",
		"document":	 fmt.Sprint(document),
		"InsertOneOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.InsertOneResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.InsertOneResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.InsertOneResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// MongoCursor contains emedded mongo.Cursor in order to override its methods
type MongoCursor struct {
	mongo.Cursor
	filter interface{}
	opts []options.FindOptions
	ctx context.Context
	log *zap.Logger
}

// Err mocks mongo's Cursor Err() in order to :
// 1. in "capture" mode, store its encoded output(generated by Cursor.Err()) into keploy's Context Deps array.
// 2. in "test" mode, decode its stored output which are present in the keploy's Context Deps array without calling Cursor.Err().
// 3. in "off" mode, returns the output generated after calling Err method of Cursor. 
//
// This method returns error occured while execution of Find method that created this instance of Cursor.
// If there is no matching document in collection then, ErrNoDocuments error is returned. 
func (cr *MongoCursor) Err() error {
	if keploy.GetMode() == "off" {
		err := cr.Cursor.Err()
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {	
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Err()
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.Err",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Close mocks mongo's Cursor Close() in order to :
// 1. in "capture" mode, stores its encoded output(generated by Cursor.Close()) into keploy's Context Deps array.
// 2. in "test" mode, decodes its stored output which are present in the keploy's Context Deps array without calling Cursor.Close().
// 3. in "off" mode, returns the output generated after calling Close method of Cursor. 
//
// Close closes this cursor. Next and TryNext must not be called after Close has been called. Close is idempotent. After
// the first call, any subsequent calls will not change the state.
func (cr *MongoCursor) Close(ctx context.Context) error{
	if keploy.GetMode() == "off" {
		err := cr.Cursor.Close(ctx)
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {	
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Close(ctx)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.Close",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// TryNext mocks mongo's Cursor TryNext() in order to :
// 1. in "capture" mode, stores its encoded output(generated by Cursor.TryNext()) into keploy's Context Deps array.
// 2. in "test" mode, decodes its stored output which are present in the keploy's Context Deps array without calling Cursor.TryNext().
// 3. in "off" mode, returns the output generated after calling TryNext method of Cursor. 
//
// TryNext is a non blocking method.
func (cr *MongoCursor) TryNext(ctx context.Context) bool{
	if keploy.GetMode() == "off" {
		return cr.Cursor.TryNext(ctx)
	}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return false
	}
	var output *bool
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		n := false
		output = &n
	case "capture":
		n := cr.Cursor.TryNext(ctx)
		output = &n
	default:	
		return false
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.TryNext",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, output)

	if mock {
		if res[0] != nil {
			output = res[0].(*bool)
		}
	}
	return *output
}

// All mocks mongo's Cursor All() in order to :
// 1. in "capture" mode, stores its encoded output(generated by Cursor.All()) into keploy's Context Deps array.
// 2. in "test" mode, decodes its stored output which are present in the keploy's Context Deps array without calling Cursor.All().
// 3. in "off" mode, returns the output generated after calling All method of Cursor. 
//
// Cursor.All method unmarshals all documents and store them into results(pointer to an array of document type) 
func (cr *MongoCursor) All(ctx context.Context, results interface{}) error{
	if keploy.GetMode() == "off" {
		err := cr.Cursor.All(ctx, results)
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {	
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.All(ctx, results)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.All",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, results, kerr)

	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Next mocks mongo's Cursor Next() in order to :
// 1. in "capture" mode, stores its encoded output(generated by Cursor.Next()) into keploy's Context Deps array.
// 2. in "test" mode, decodes its stored output which are present in the keploy's Context Deps array without calling Cursor.Next().
// 3. in "off" mode, returns the output generated after calling Next method of Cursor. 
//
// Next function returns boolean that whether the batch is empty or not. returns false if there 
// there is no more document matching with filter.
func (cr *MongoCursor) Next(ctx context.Context) bool {
	if keploy.GetMode() == "off" {
		return cr.Cursor.Next(ctx)
	}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return false
	}
	var output *bool
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		n := false
		output = &n
	case "capture":
		n := cr.Cursor.Next(ctx)
		output = &n
	default:	
		return false
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.Next",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, output)

	if mock {
		if res[0] != nil {
			output = res[0].(*bool)
		}
	}
	return *output
}

// Decode mocks mongo's Cursor Decode() in order to :
// 1. in "capture" mode, stores its encoded output(generated by Cursor.Decode()) into keploy's Context Deps array.
// 2. in "test" mode, decodes its stored output which are present in the keploy's Context Deps array without calling Cursor.Decode().
// 3. in "off" mode, returns the output generated after calling Decode method of Cursor. 
//
// Decode functions decodes []byte into v parameter. v is a pointer to variable of document type
func (cr *MongoCursor) Decode(v interface{}) error {
	if keploy.GetMode() == "off" {
		err := cr.Cursor.Decode(v)
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {	
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Decode(v)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "Find.Decode",
		"filter":	 fmt.Sprint(cr.filter),
		"FindOptions": fmt.Sprint(cr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, v, kerr)

	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Find creates and returns the instance of pointer to MongoCursor which have overridden methods of mongo.Cursor.
// Actual Collection.Find is called only in "capture" or "off" mode.
//
// The filter parameter must be a document containing query operators and can be used to select which documents are
// included in the result. It cannot be nil. An empty document (e.g. bson.D{}) should be used to include all documents.
//
// The opts parameter can be used to specify options for the operation (see the options.FindOptions documentation).
// 
func (c *MongoCollection) Find(ctx context.Context, filter interface{},
	opts ...*options.FindOptions) (*MongoCursor, error) {
	if keploy.GetMode() == "off" {
		cursor, err := c.Collection.Find(ctx, filter, opts...)
		return &MongoCursor{
			Cursor: *cursor,
			filter: filter,
			ctx:    ctx,
			log:    c.log,
		}, err
	}

	derivedOpts := []options.FindOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return &MongoCursor{
			filter: filter,
			opts: derivedOpts,
			log: c.log,
			ctx: ctx,
		}, er
	}
	mode := kctx.Mode
	var (
		cursor *mongo.Cursor
		err    error
	)
	switch mode {
	case "test":
		//don't call method in test mode
		return &MongoCursor{
			filter: filter,
			opts: derivedOpts,
			log: c.log,
			ctx: ctx,
		}, err
	case "capture":
		cursor, err = c.Collection.Find(ctx, filter, opts...)
		return &MongoCursor{
			Cursor: *cursor,
			filter: filter,
			opts: derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, err
	default:
		c.log.Error("integrations: Not in a valid sdk mode")
		return &MongoCursor{
			filter: filter,
			opts: derivedOpts,
			log: c.log,
			ctx: ctx,
		}, errors.New("integrations: Not in a valid sdk mode")
	}

}

// InsertMany method mocks Collection.InsertMany of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.InsertMany) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.InsertMany.
// 3. in "off" mode, returns the output from calling actual Collection.InsertMany method.
// 
// documents parameter is the slice of documents that is to be inserted. It should not be nil 
// or empty. Also the elements of slice should not be nil.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.InsertMany for
// more information about Collection.InsertMany
func (c *MongoCollection) InsertMany(ctx context.Context, documents []interface{},
	opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.InsertMany(ctx, documents, opts...)
		return output, err
	}
	var output *mongo.InsertManyResult = &mongo.InsertManyResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, documents)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "InsertMany", data)
	if o != nil {
		output = o.(*mongo.InsertManyResult)
	}
	err = e

	derivedOpts := []options.InsertManyOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "InsertMany",
		"documents":	 fmt.Sprint(documents),
		"InsertManyOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.InsertManyResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.InsertManyResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.InsertManyResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// UpdateOne method mocks Collection.UpdateOne of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.UpdateOne) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.UpdateOne.
// 3. in "off" mode, returns the output from calling actual Collection.UpdateOne method.
// 
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.UpdateOne for 
// information about Collection.UpdateOne.
func (c *MongoCollection) UpdateOne(ctx context.Context, filter interface{}, update interface{},
	opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.UpdateOne(ctx, filter, update, opts...)
		return output, err
	}
	var output *mongo.UpdateResult = &mongo.UpdateResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	data = append(data, update)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "UpdateOne", data)
	if o != nil {
		output = o.(*mongo.UpdateResult)
	}
	err = e

	derivedOpts := []options.UpdateOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "UpdateOne",
		"filter":	 fmt.Sprint(filter),
		"update":	 fmt.Sprint(update),
		"UpdateOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		c.log.Error(err.Error())
		output = &mongo.UpdateResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.UpdateResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.UpdateResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// UpdateMany method mocks Collection.UpdateMany of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.UpdateMany) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.UpdateMany.
// 3. in "off" mode, returns the output from calling actual Collection.UpdateMany method.
// 
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.UpdateMany for 
// information about Collection.UpdateMany.
func (c *MongoCollection) UpdateMany(ctx context.Context, filter interface{}, update interface{},
	opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.UpdateMany(ctx, filter, update, opts...)
		return output, err
	}
	var output *mongo.UpdateResult = &mongo.UpdateResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	data = append(data, update)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "UpdateMany", data)
	if o != nil {
		output = o.(*mongo.UpdateResult)
	}
	err = e

	derivedOpts := []options.UpdateOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "UpdateMany",
		"filter":	 fmt.Sprint(filter),
		"update":	 fmt.Sprint(update),
		"UpdateOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		c.log.Error(err.Error())
		output = &mongo.UpdateResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.UpdateResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.UpdateResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// DeleteOne method mocks Collection.DeleteOne of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.DeleteOne) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.DeleteOne.
// 3. in "off" mode, returns the output from calling actual Collection.DeleteOne method.
// 
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.DeleteOne for 
// information about Collection.DeleteOne.
func (c *MongoCollection) DeleteOne(ctx context.Context, filter interface{},
	opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.DeleteOne(ctx, filter, opts...)
		return output, err
	}
	var output *mongo.DeleteResult = &mongo.DeleteResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "DeleteOne", data)
	if o != nil {
		output = o.(*mongo.DeleteResult)
	}
	err = e

	derivedOpts := []options.DeleteOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "DeleteOne",
		"filter":	 fmt.Sprint(filter),
		"DeleteOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		c.log.Error(err.Error())
		output = &mongo.DeleteResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.DeleteResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.DeleteResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// DeleteMany method mocks Collection.DeleteMany of mongo. It does the following:
// 1. in "capture" mode, stores the encoded output(generated from Collection.DeleteMany) in the keploy's Context Deps array .
// 2. in "test" mode, decodes the stored output from the keploy's Context Deps array without calling Collection.DeleteMany.
// 3. in "off" mode, returns the output from calling actual Collection.DeleteMany method.
// 
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.DeleteMany for 
// information about Collection.DeleteMany.
func (c *MongoCollection) DeleteMany(ctx context.Context, filter interface{},
	opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	if keploy.GetMode() == "off" {
		output, err := c.Collection.DeleteMany(ctx, filter, opts...)
		return output, err
	}
	var output *mongo.DeleteResult = &mongo.DeleteResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "DeleteMany", data)
	if o != nil {
		output = o.(*mongo.DeleteResult)
	}
	err = e

	derivedOpts := []options.DeleteOptions{}
	for _,j := range opts{
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":      "mongodb",
		"type":      string(keploy.NoSqlDB),
		"operation": "DeleteMany",
		"filter":	 fmt.Sprint(filter),
		"DeleteOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		c.log.Error(err.Error())
		output = &mongo.DeleteResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.DeleteResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.DeleteResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

func (c *MongoCollection) getOutput(ctx context.Context, str string, data []interface{}) (interface{}, error) {
	var (
		output interface{}
		err    error
	)
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return nil, er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		output, err = c.callMethod(ctx, str, data)

	default:
		return nil, errors.New("integrations: Not in a valid sdk mode")
	}
	return output, err
}

func (c *MongoCollection) callMethod(ctx context.Context, str string, data []interface{}) (interface{}, error) {
	var (
		output interface{}
		err    error
	)
	switch str {
	case "InsertOne":
		doc := data[0]
		data = data[1:]
		var opts []*options.InsertOneOptions
		for _, d := range data {
			opts = append(opts, d.(*options.InsertOneOptions))
		}
		output, err = c.Collection.InsertOne(ctx, doc, opts...)
	case "InsertMany":
		doc := data[0].([]interface{})
		data = data[1:]
		var opts []*options.InsertManyOptions
		for _, d := range data {
			opts = append(opts, d.(*options.InsertManyOptions))
		}
		output, err = c.Collection.InsertMany(ctx, doc, opts...)
	case "UpdateOne":
		filter := data[0]
		update := data[1]
		data = data[2:]
		var opts []*options.UpdateOptions
		for _, d := range data {
			opts = append(opts, d.(*options.UpdateOptions))
		}
		output, err = c.Collection.UpdateOne(ctx, filter, update, opts...)
	case "UpdateMany":
		filter := data[0]
		update := data[1]
		data = data[2:]
		var opts []*options.UpdateOptions
		for _, d := range data {
			opts = append(opts, d.(*options.UpdateOptions))
		}
		output, err = c.Collection.UpdateMany(ctx, filter, update, opts...)
	case "DeleteOne":
		filter := data[0]
		data = data[1:]
		var opts []*options.DeleteOptions
		for _, d := range data {
			opts = append(opts, d.(*options.DeleteOptions))
		}
		output, err = c.Collection.DeleteOne(ctx, filter, opts...)
	case "DeleteMany":
		filter := data[0]
		data = data[1:]
		var opts []*options.DeleteOptions
		for _, d := range data {
			opts = append(opts, d.(*options.DeleteOptions))
		}
		output, err = c.Collection.DeleteMany(ctx, filter, opts...)
	default:
		return nil, errors.New("integerations: SDK Not supported for this method")
	}
	return output, err
}
